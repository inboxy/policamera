/**
 * Point Cloud Generator for E57 File Format
 * Creates 3D point clouds and exports them to E57 format
 * E57 is a standard format for 3D imaging data exchange
 */

class PointCloudE57 {
    constructor() {
        this.points = [];
        this.metadata = {
            coordinateMetadata: null,
            creationDateTime: new Date().toISOString(),
            description: "Point cloud generated by PoliCamera",
            libraryVersion: "1.0.0",
            formatName: "ASTM E57 3D Imaging Data Exchange",
            version: "1.0"
        };
        this.scanPositions = [];
        this.images = [];
        this.currentScanIndex = 0;
    }

    /**
     * Add a 3D point to the point cloud
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @param {number} z - Z coordinate
     * @param {number} intensity - Point intensity (0-1)
     * @param {Object} color - RGB color {r, g, b} (0-255)
     * @param {number} scanIndex - Index of the scan this point belongs to
     */
    addPoint(x, y, z, intensity = 1.0, color = null, scanIndex = 0) {
        const point = {
            cartesianX: x,
            cartesianY: y,
            cartesianZ: z,
            intensity: Math.max(0, Math.min(1, intensity)),
            scanIndex: scanIndex
        };

        if (color) {
            point.colorRed = Math.max(0, Math.min(255, color.r));
            point.colorGreen = Math.max(0, Math.min(255, color.g));
            point.colorBlue = Math.max(0, Math.min(255, color.b));
        }

        this.points.push(point);
    }

    /**
     * Add multiple points from an array
     * @param {Array} pointsArray - Array of point objects
     */
    addPoints(pointsArray) {
        pointsArray.forEach(point => {
            this.addPoint(
                point.x, point.y, point.z,
                point.intensity,
                point.color,
                point.scanIndex || 0
            );
        });
    }

    /**
     * Create a scan position (sensor position and orientation)
     * @param {Object} position - {x, y, z} position
     * @param {Object} rotation - {x, y, z, w} quaternion rotation
     * @param {string} name - Name of the scan position
     */
    addScanPosition(position, rotation, name = null) {
        const scanPosition = {
            name: name || `Scan_${this.scanPositions.length}`,
            pose: {
                translation: {
                    x: position.x || 0,
                    y: position.y || 0,
                    z: position.z || 0
                },
                rotation: {
                    x: rotation.x || 0,
                    y: rotation.y || 0,
                    z: rotation.z || 0,
                    w: rotation.w || 1
                }
            },
            acquisitionStart: new Date().toISOString(),
            acquisitionEnd: new Date().toISOString()
        };

        this.scanPositions.push(scanPosition);
        return this.scanPositions.length - 1;
    }

    /**
     * Add an associated image to the point cloud
     * @param {string} name - Image name
     * @param {string} imageData - Base64 encoded image data
     * @param {Object} pose - Camera pose {position, rotation}
     * @param {Object} intrinsics - Camera intrinsics {focalLength, principalPoint, etc.}
     */
    addImage(name, imageData, pose = null, intrinsics = null) {
        const image = {
            name: name,
            imageData: imageData,
            acquisitionDateTime: new Date().toISOString()
        };

        if (pose) {
            image.pose = pose;
        }

        if (intrinsics) {
            image.intrinsics = intrinsics;
        }

        this.images.push(image);
    }

    /**
     * Generate point cloud from depth map and camera parameters
     * @param {ImageData} depthMap - Depth map image data
     * @param {Object} cameraParams - Camera parameters
     * @param {Object} pose - Camera pose
     */
    generateFromDepthMap(depthMap, cameraParams, pose = null) {
        const { width, height, data } = depthMap;
        const { focalLengthX, focalLengthY, principalPointX, principalPointY, depthScale } = cameraParams;

        const scanIndex = this.addScanPosition(
            pose?.position || { x: 0, y: 0, z: 0 },
            pose?.rotation || { x: 0, y: 0, z: 0, w: 1 },
            'DepthMap_Scan'
        );

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const pixelIndex = (y * width + x) * 4;

                // Assuming depth is stored in the red channel (grayscale)
                const depthValue = data[pixelIndex] * (depthScale || 1.0);

                if (depthValue > 0) {
                    // Convert pixel coordinates to 3D coordinates
                    const worldX = (x - principalPointX) * depthValue / focalLengthX;
                    const worldY = (y - principalPointY) * depthValue / focalLengthY;
                    const worldZ = depthValue;

                    // Apply pose transformation if provided
                    let finalX = worldX;
                    let finalY = worldY;
                    let finalZ = worldZ;

                    if (pose && pose.position) {
                        finalX += pose.position.x;
                        finalY += pose.position.y;
                        finalZ += pose.position.z;
                    }

                    // Calculate intensity from depth
                    const intensity = Math.min(1.0, depthValue / 10.0);

                    // Extract color if available
                    const color = {
                        r: data[pixelIndex],
                        g: data[pixelIndex + 1],
                        b: data[pixelIndex + 2]
                    };

                    this.addPoint(finalX, finalY, finalZ, intensity, color, scanIndex);
                }
            }
        }
    }

    /**
     * Generate synthetic point cloud (for testing)
     * @param {number} numPoints - Number of points to generate
     * @param {Object} bounds - Bounding box {min: {x, y, z}, max: {x, y, z}}
     */
    generateSyntheticCloud(numPoints = 1000, bounds = null) {
        const defaultBounds = {
            min: { x: -10, y: -10, z: 0 },
            max: { x: 10, y: 10, z: 10 }
        };

        const useBounds = bounds || defaultBounds;
        const scanIndex = this.addScanPosition(
            { x: 0, y: 0, z: 0 },
            { x: 0, y: 0, z: 0, w: 1 },
            'Synthetic_Scan'
        );

        for (let i = 0; i < numPoints; i++) {
            const x = Math.random() * (useBounds.max.x - useBounds.min.x) + useBounds.min.x;
            const y = Math.random() * (useBounds.max.y - useBounds.min.y) + useBounds.min.y;
            const z = Math.random() * (useBounds.max.z - useBounds.min.z) + useBounds.min.z;

            const intensity = Math.random();
            const color = {
                r: Math.floor(Math.random() * 256),
                g: Math.floor(Math.random() * 256),
                b: Math.floor(Math.random() * 256)
            };

            this.addPoint(x, y, z, intensity, color, scanIndex);
        }
    }

    /**
     * Calculate bounding box of all points
     */
    getBoundingBox() {
        if (this.points.length === 0) {
            return null;
        }

        const bounds = {
            min: {
                x: Number.MAX_VALUE,
                y: Number.MAX_VALUE,
                z: Number.MAX_VALUE
            },
            max: {
                x: Number.MIN_VALUE,
                y: Number.MIN_VALUE,
                z: Number.MIN_VALUE
            }
        };

        this.points.forEach(point => {
            bounds.min.x = Math.min(bounds.min.x, point.cartesianX);
            bounds.min.y = Math.min(bounds.min.y, point.cartesianY);
            bounds.min.z = Math.min(bounds.min.z, point.cartesianZ);
            bounds.max.x = Math.max(bounds.max.x, point.cartesianX);
            bounds.max.y = Math.max(bounds.max.y, point.cartesianY);
            bounds.max.z = Math.max(bounds.max.z, point.cartesianZ);
        });

        return bounds;
    }

    /**
     * Generate E57 XML structure
     */
    generateE57XML() {
        const bounds = this.getBoundingBox();

        const xml = `<?xml version="1.0" encoding="UTF-8"?>
<e57Root type="Structure" xmlns="http://www.astm.org/COMMIT/E57/2010-e57-v1.0">
    <formatName type="String"><![CDATA[${this.metadata.formatName}]]></formatName>
    <guid type="String"><![CDATA[{${this.generateGUID()}}]]></guid>
    <versionMajor type="Integer">${this.metadata.version.split('.')[0]}</versionMajor>
    <versionMinor type="Integer">${this.metadata.version.split('.')[1] || 0}</versionMinor>
    <e57LibraryVersion type="String"><![CDATA[${this.metadata.libraryVersion}]]></e57LibraryVersion>
    <coordinateMetadata type="String"><![CDATA[${this.metadata.coordinateMetadata || 'No coordinate system specified'}]]></coordinateMetadata>
    <creationDateTime type="Structure">
        <dateTimeValue type="Float">${new Date(this.metadata.creationDateTime).getTime() / 1000}</dateTimeValue>
        <isAtomicClockReferenced type="Integer">0</isAtomicClockReferenced>
    </creationDateTime>
    <data3D type="Vector" allowHeterogeneousChildren="1">
        ${this.generateScanXML()}
    </data3D>
    ${this.images.length > 0 ? this.generateImagesXML() : ''}
</e57Root>`;

        return xml;
    }

    /**
     * Generate XML for scans
     */
    generateScanXML() {
        let scanXML = '';

        // Group points by scan index
        const scanGroups = {};
        this.points.forEach(point => {
            if (!scanGroups[point.scanIndex]) {
                scanGroups[point.scanIndex] = [];
            }
            scanGroups[point.scanIndex].push(point);
        });

        Object.keys(scanGroups).forEach((scanIndex, index) => {
            const points = scanGroups[scanIndex];
            const scanPosition = this.scanPositions[scanIndex] || {
                name: `Scan_${scanIndex}`,
                pose: {
                    translation: { x: 0, y: 0, z: 0 },
                    rotation: { x: 0, y: 0, z: 0, w: 1 }
                }
            };

            const bounds = this.calculateBoundsForPoints(points);

            scanXML += `
        <vectorChild type="Structure">
            <guid type="String"><![CDATA[{${this.generateGUID()}}]]></guid>
            <name type="String"><![CDATA[${scanPosition.name}]]></name>
            <description type="String"><![CDATA[Point cloud scan data]]></description>
            <sensorVendor type="String"><![CDATA[PoliCamera]]></sensorVendor>
            <sensorModel type="String"><![CDATA[PointCloudGenerator]]></sensorModel>
            <sensorSerialNumber type="String"><![CDATA[PC-001]]></sensorSerialNumber>
            <sensorHardwareVersion type="String"><![CDATA[1.0]]></sensorHardwareVersion>
            <sensorSoftwareVersion type="String"><![CDATA[1.0]]></sensorSoftwareVersion>
            <sensorFirmwareVersion type="String"><![CDATA[1.0]]></sensorFirmwareVersion>
            <pose type="Structure">
                <translation type="Structure">
                    <x type="Float">${scanPosition.pose.translation.x}</x>
                    <y type="Float">${scanPosition.pose.translation.y}</y>
                    <z type="Float">${scanPosition.pose.translation.z}</z>
                </translation>
                <rotation type="Structure">
                    <x type="Float">${scanPosition.pose.rotation.x}</x>
                    <y type="Float">${scanPosition.pose.rotation.y}</y>
                    <z type="Float">${scanPosition.pose.rotation.z}</z>
                    <w type="Float">${scanPosition.pose.rotation.w}</w>
                </rotation>
            </pose>
            <acquisitionStart type="Structure">
                <dateTimeValue type="Float">${new Date().getTime() / 1000}</dateTimeValue>
                <isAtomicClockReferenced type="Integer">0</isAtomicClockReferenced>
            </acquisitionStart>
            <acquisitionEnd type="Structure">
                <dateTimeValue type="Float">${new Date().getTime() / 1000}</dateTimeValue>
                <isAtomicClockReferenced type="Integer">0</isAtomicClockReferenced>
            </acquisitionEnd>
            <pointCount type="Integer">${points.length}</pointCount>
            <points type="CompressedVector" fileOffset="${this.calculateOffset(index)}" recordCount="${points.length}">
                <prototype type="Structure">
                    <cartesianX type="Float" precision="double"/>
                    <cartesianY type="Float" precision="double"/>
                    <cartesianZ type="Float" precision="double"/>
                    <intensity type="Float" precision="single"/>
                    ${points.some(p => p.colorRed !== undefined) ? `
                    <colorRed type="Integer" minimum="0" maximum="255"/>
                    <colorGreen type="Integer" minimum="0" maximum="255"/>
                    <colorBlue type="Integer" minimum="0" maximum="255"/>` : ''}
                </prototype>
                <codecs type="Vector" allowHeterogeneousChildren="1">
                    <vectorChild type="Structure">
                        <type type="String"><![CDATA[CompressedVectorWriter]]></type>
                    </vectorChild>
                </codecs>
            </points>
            <cartesianBounds type="Structure">
                <xMinimum type="Float">${bounds.min.x}</xMinimum>
                <xMaximum type="Float">${bounds.max.x}</xMaximum>
                <yMinimum type="Float">${bounds.min.y}</yMinimum>
                <yMaximum type="Float">${bounds.max.y}</yMaximum>
                <zMinimum type="Float">${bounds.min.z}</zMinimum>
                <zMaximum type="Float">${bounds.max.z}</zMaximum>
            </cartesianBounds>
        </vectorChild>`;
        });

        return scanXML;
    }

    /**
     * Generate XML for images
     */
    generateImagesXML() {
        if (this.images.length === 0) return '';

        let imagesXML = '<images2D type="Vector" allowHeterogeneousChildren="1">';

        this.images.forEach((image, index) => {
            imagesXML += `
        <vectorChild type="Structure">
            <guid type="String"><![CDATA[{${this.generateGUID()}}]]></guid>
            <name type="String"><![CDATA[${image.name}]]></name>
            <description type="String"><![CDATA[Associated camera image]]></description>
            <acquisitionDateTime type="Structure">
                <dateTimeValue type="Float">${new Date(image.acquisitionDateTime).getTime() / 1000}</dateTimeValue>
                <isAtomicClockReferenced type="Integer">0</isAtomicClockReferenced>
            </acquisitionDateTime>
            ${image.pose ? `
            <pose type="Structure">
                <translation type="Structure">
                    <x type="Float">${image.pose.position.x}</x>
                    <y type="Float">${image.pose.position.y}</y>
                    <z type="Float">${image.pose.position.z}</z>
                </translation>
                <rotation type="Structure">
                    <x type="Float">${image.pose.rotation.x}</x>
                    <y type="Float">${image.pose.rotation.y}</y>
                    <z type="Float">${image.pose.rotation.z}</z>
                    <w type="Float">${image.pose.rotation.w}</w>
                </rotation>
            </pose>` : ''}
            <visualReferenceRepresentation type="Structure">
                <jpegImage type="Blob" fileOffset="${this.calculateImageOffset(index)}" length="${image.imageData.length}"/>
            </visualReferenceRepresentation>
        </vectorChild>`;
        });

        imagesXML += '</images2D>';
        return imagesXML;
    }

    /**
     * Calculate file offset for point data (simplified)
     */
    calculateOffset(scanIndex) {
        // Simplified offset calculation
        // In a real implementation, this would track actual file positions
        return 1024 + (scanIndex * 1000000);
    }

    /**
     * Calculate file offset for image data (simplified)
     */
    calculateImageOffset(imageIndex) {
        // Simplified offset calculation for images
        return 5000000 + (imageIndex * 500000);
    }

    /**
     * Calculate bounds for a subset of points
     */
    calculateBoundsForPoints(points) {
        if (points.length === 0) {
            return { min: { x: 0, y: 0, z: 0 }, max: { x: 0, y: 0, z: 0 } };
        }

        const bounds = {
            min: {
                x: Number.MAX_VALUE,
                y: Number.MAX_VALUE,
                z: Number.MAX_VALUE
            },
            max: {
                x: Number.MIN_VALUE,
                y: Number.MIN_VALUE,
                z: Number.MIN_VALUE
            }
        };

        points.forEach(point => {
            bounds.min.x = Math.min(bounds.min.x, point.cartesianX);
            bounds.min.y = Math.min(bounds.min.y, point.cartesianY);
            bounds.min.z = Math.min(bounds.min.z, point.cartesianZ);
            bounds.max.x = Math.max(bounds.max.x, point.cartesianX);
            bounds.max.y = Math.max(bounds.max.y, point.cartesianY);
            bounds.max.z = Math.max(bounds.max.z, point.cartesianZ);
        });

        return bounds;
    }

    /**
     * Generate a GUID for E57 elements
     */
    generateGUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    /**
     * Generate binary point cloud data
     */
    generateBinaryData() {
        // Create binary data for points
        const pointSize = 24 + (this.hasColors() ? 3 : 0); // 3 doubles + 1 float + optional RGB
        const buffer = new ArrayBuffer(this.points.length * pointSize);
        const dataView = new DataView(buffer);

        let offset = 0;
        this.points.forEach(point => {
            // Write coordinates as double precision
            dataView.setFloat64(offset, point.cartesianX, true);
            dataView.setFloat64(offset + 8, point.cartesianY, true);
            dataView.setFloat64(offset + 16, point.cartesianZ, true);

            // Write intensity as single precision
            dataView.setFloat32(offset + 24, point.intensity, true);

            offset += 28;

            // Write colors if available
            if (this.hasColors() && point.colorRed !== undefined) {
                dataView.setUint8(offset, point.colorRed);
                dataView.setUint8(offset + 1, point.colorGreen);
                dataView.setUint8(offset + 2, point.colorBlue);
                offset += 3;
            }
        });

        return buffer;
    }

    /**
     * Check if point cloud has color information
     */
    hasColors() {
        return this.points.some(point => point.colorRed !== undefined);
    }

    /**
     * Export to E57 format
     * @param {string} filename - Output filename
     * @returns {Object} - Object containing XML and binary data
     */
    exportToE57(filename = 'pointcloud.e57') {
        const xmlData = this.generateE57XML();
        const binaryData = this.generateBinaryData();

        return {
            filename: filename,
            xml: xmlData,
            binary: binaryData,
            metadata: {
                pointCount: this.points.length,
                scanCount: this.scanPositions.length,
                imageCount: this.images.length,
                hasColors: this.hasColors(),
                bounds: this.getBoundingBox()
            }
        };
    }

    /**
     * Download E57 file (browser environment)
     */
    downloadE57(filename = 'pointcloud.e57') {
        const e57Data = this.exportToE57(filename);

        // Create simplified E57 file (XML only for demo)
        const blob = new Blob([e57Data.xml], { type: 'application/xml' });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.click();

        URL.revokeObjectURL(url);

        console.log('E57 Export Summary:', e57Data.metadata);
    }

    /**
     * Clear all point cloud data
     */
    clear() {
        this.points = [];
        this.scanPositions = [];
        this.images = [];
        this.currentScanIndex = 0;
    }

    /**
     * Get statistics about the point cloud
     */
    getStatistics() {
        return {
            totalPoints: this.points.length,
            totalScans: this.scanPositions.length,
            totalImages: this.images.length,
            hasColors: this.hasColors(),
            bounds: this.getBoundingBox(),
            memoryUsage: this.estimateMemoryUsage()
        };
    }

    /**
     * Estimate memory usage in bytes
     */
    estimateMemoryUsage() {
        const pointSize = 32 + (this.hasColors() ? 3 : 0); // Approximate size per point
        return this.points.length * pointSize;
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PointCloudE57;
} else if (typeof window !== 'undefined') {
    window.PointCloudE57 = PointCloudE57;
}